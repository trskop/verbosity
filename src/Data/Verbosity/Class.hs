{-# LANGUAGE NoImplicitPrelude #-}
-- |
-- Module:       $HEADER$
-- Description:  Type class for accessing Verbosity.
-- Copyright:    (c) 2015-2018 Peter TrÅ¡ko
-- License:      BSD3
--
-- Maintainer:   peter.trsko@gmail.com
-- Stability:    experimental
-- Portability:  GHC specific language extensions.
--
-- Type class for accessing 'Verbosity'.
module Data.Verbosity.Class
    (
    -- * Hand Written Instance Example
    --
    -- $basicUsageExample

    -- * TemplateHaskell Example
    --
    -- $thUsageExample

    -- * Generic-Lens Example
    --
    -- $genericLensExample

    -- * HasVerbosity Type Class
      HasVerbosity(..)
    , getVerbosity
    , setVerbosity
    , modifyVerbosity

    -- * Verbosity Re-export
    , module Data.Verbosity
    )
  where

import Control.Applicative (Const(Const, getConst))
import Data.Function ((.), ($), const)
import Data.Functor (Functor)
import Data.Functor.Identity (Identity(Identity, runIdentity))

import Data.Verbosity


class HasVerbosity s where
    -- | Lens for accessing 'Verbosity' embedded in the type @s@.
    verbosity :: Functor f => (Verbosity -> f Verbosity) -> s -> f s

instance HasVerbosity Verbosity where
    verbosity = ($)

-- | Specialization of 'verbosity' lens in to getter function.
getVerbosity :: HasVerbosity s => s -> Verbosity
getVerbosity = getConst . verbosity Const

-- | Specialization of 'verbosity' lens in to setter function.
setVerbosity :: HasVerbosity s => Verbosity -> s -> s
setVerbosity v = runIdentity . verbosity (const (Identity v))

-- | Specialization of 'verbosity' lens in to modification function.
modifyVerbosity :: HasVerbosity s => (Verbosity -> Verbosity) -> s -> s
modifyVerbosity f = runIdentity . verbosity (Identity . f)

-- $basicUsageExample
--
-- Lets define simple data type that looks something like:
--
-- @
-- data Config = Config
--     { _appVerbosity :: 'Verbosity'
--     , ...
--     }
--   deriving (Show, ...)
-- @
--
-- Now we can define instance of 'HasVerbosity' by hand:
--
-- @
-- instance 'HasVerbosity' Config where
--     verbosity f c@Config{_appVerbosity = a} =
--         (\\b -> c{_appVerbosity = b}) 'Data.Functor.<$>' f a
-- @

-- $thUsageExample
--
-- Package [lens](https://hackage.haskell.org/package/lens) has TemplateHaskell
-- functions that can define lenses for you:
--
-- @
-- {-\# LANGUAGE TemplateHaskell \#-}
--
-- import Control.Lens.TH (makeLenses)
--
-- data Config = Config
--     { _appVerbosity :: 'Verbosity'
--     , ...
--     }
--   deriving (Show, ...)
--
-- makeLenses ''Config
-- @
--
-- Now definition of 'HasVerbosity' instance will look like:
--
-- @
-- instance 'HasVerbosity' Config where
--     'verbosity' = appVerbosity   -- Lens generated by makeLenses.
-- @

-- $genericLensExample
--
-- Package [generic-lens](http://hackage.haskell.org/package/generic-lens) uses
-- GHC Generics to provide efficient lenses without the need of defining them
-- manually or having to use TemplateHaskell.
--
-- @
-- {-\# LANGUAGE DeriveGeneric \#-}
--
-- import "GHC.Generics" ('GHC.Generics.Generic')
-- import Data.Generics.Product.Typed (HasType(typed))
--
--
-- data Config = Config
--     { _appVerbosity :: 'Verbosity'
--     , ...
--     }
--   deriving ('GHC.Generics.Generic', Show, ...)
--
-- instance 'HasVerbosity' Config where
--     'verbosity' = typed
-- @
